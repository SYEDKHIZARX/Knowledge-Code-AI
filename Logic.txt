# Create logic.py file in Colab so "from logic import *" works
%%writefile logic.py
import itertools

class Sentence():
    def evaluate(self, model):
        raise Exception("nothing to evaluate")
    def formula(self):
        return ""
    def symbols(self):
        return set()
    @classmethod
    def validate(cls, sentence):
        if not isinstance(sentence, Sentence):
            raise TypeError("must be a logical sentence")
    @classmethod
    def parenthesize(cls, s):
        def balanced(s):
            count = 0
            for c in s:
                if c == "(":
                    count += 1
                elif c == ")":
                    if count <= 0:
                        return False
                    count -= 1
            return count == 0
        if not len(s) or s.isalpha() or (
            s[0] == "(" and s[-1] == ")" and balanced(s[1:-1])
        ):
            return s
        else:
            return f"({s})"


class Symbol(Sentence):
    def __init__(self, name):
        self.name = name
    def __eq__(self, other):
        return isinstance(other, Symbol) and self.name == other.name
    def __hash__(self):
        return hash(("symbol", self.name))
    def __repr__(self):
        return self.name
    def evaluate(self, model):
        return model.get(self.name, False)
    def symbols(self):
        return {self.name}


class Not(Sentence):
    def __init__(self, operand):
        Sentence.validate(operand)
        self.operand = operand
    def evaluate(self, model):
        return not self.operand.evaluate(model)
    def symbols(self):
        return self.operand.symbols()
    def __repr__(self):
        return f"Not({self.operand})"


class And(Sentence):
    def __init__(self, *conjuncts):
        for conjunct in conjuncts:
            Sentence.validate(conjunct)
        self.conjuncts = list(conjuncts)
    def add(self, conjunct):
        Sentence.validate(conjunct)
        self.conjuncts.append(conjunct)
    def evaluate(self, model):
        return all(c.evaluate(model) for c in self.conjuncts)
    def symbols(self):
        return set.union(*[c.symbols() for c in self.conjuncts])
    def __repr__(self):
        return "And(" + ", ".join(str(c) for c in self.conjuncts) + ")"


class Or(Sentence):
    def __init__(self, *disjuncts):
        for d in disjuncts:
            Sentence.validate(d)
        self.disjuncts = list(disjuncts)
    def evaluate(self, model):
        return any(d.evaluate(model) for d in self.disjuncts)
    def symbols(self):
        return set.union(*[d.symbols() for d in self.disjuncts])
    def __repr__(self):
        return "Or(" + ", ".join(str(d) for d in self.disjuncts) + ")"


class Implication(Sentence):
    def __init__(self, antecedent, consequent):
        Sentence.validate(antecedent)
        Sentence.validate(consequent)
        self.antecedent = antecedent
        self.consequent = consequent
    def evaluate(self, model):
        return (not self.antecedent.evaluate(model)) or self.consequent.evaluate(model)
    def symbols(self):
        return self.antecedent.symbols() | self.consequent.symbols()
    def __repr__(self):
        return f"Implication({self.antecedent}, {self.consequent})"


class Biconditional(Sentence):
    def __init__(self, left, right):
        Sentence.validate(left)
        Sentence.validate(right)
        self.left = left
        self.right = right
    def evaluate(self, model):
        return self.left.evaluate(model) == self.right.evaluate(model)
    def symbols(self):
        return self.left.symbols() | self.right.symbols()
    def __repr__(self):
        return f"Biconditional({self.left}, {self.right})"


def model_check(knowledge, query):
    symbols = list(knowledge.symbols() | query.symbols())
    def check_all(knowledge, query, symbols, model):
        if not symbols:
            if knowledge.evaluate(model):
                return query.evaluate(model)
            return True
        remaining = symbols.copy()
        p = remaining.pop()
        model_true = model.copy()
        model_true[p] = True
        model_false = model.copy()
        model_false[p] = False
        return (
            check_all(knowledge, query, remaining, model_true)
            and check_all(knowledge, query, remaining, model_false)
        )
    return check_all(knowledge, query, symbols, {})
